/*

---------------------------------------------------------------------------------------------


 Почему JavaScript называют свободно типизированным или динамическим языком?


 JavaScript называется свободно типизированным или динамическим языком, потому что переменные JavaScript не связаны напрямую с каким-либо типом значения, и любой переменной можно присваивать и переназначать значения всех типов.


---------------------------------------------------------------------------------------------
 В чем разница между var, letи const?

 var могут быть переобъявлены и обновлены.
 let может быть обновлен, но не объявлен
 const не может быть обновлен или переобъявлен.

---------------------------------------------------------------------------------------------
В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?


Необъявленные переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи var, let или const. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка ReferenceError, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок try/catch.
function foo() {
  x = 1; // ReferenceError в строгом режиме
}
foo();
console.log(x); // 1

Переменная undefined — это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип undefined. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение undefined. Чтобы проверить это, сравните, используя оператор строгого равенства (===) или typeof, который вернет строку undefined. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет true, если значение равно null.
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === ‘undefined’); // true
console.log(foo == null); // true. Неправильно, не используйте это для проверки!
function bar() {}
var baz = bar();
console.log(baz); // undefined

Переменной со значением null было явно присвоено значение null. Она отличается от undefined тем, что она была назначена явно. Чтобы проверить на null, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (==) для проверки, так как он также вернет true, если значение равно undefined.
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === ‘object’); // true
console.log(foo == undefined); // true. Неправильно, не используйте это для проверки!

---------------------------------------------------------------------------------------------


 Для чего используется typeof оператор?

 typeof оператор возвращает строку, указывающую тип операнда.

---------------------------------------------------------------------------------------------


 Как проверить, является ли объект массивом?

     isArray()Функция определяет, является ли объект массивом.

---------------------------------------------------------------------------------------------


 Что такое Call back функция?

 это функция, которая передается в другую функцию в качестве параметра

---------------------------------------------------------------------------------------------


 Что такое модули ES6?

     Они организуют связанный набор кода JavaScript. Модуль может содержать переменные и функции. Модуль — это не что иное, как фрагмент кода JavaScript, записанный в файле.


---------------------------------------------------------------------------------------------


 Назовите два разных экспорта ES6.
     Экспорт по умолчанию(default) используется, когда модулю нужно экспортировать только одно значение.
     Именованные экспорты отличаются своими именами. В модуле может быть несколько именованных экспортов.

---------------------------------------------------------------------------------------------


 Логические операторы


---------------------------------------------------------------------------------------------

 Особенности оператора &&


---------------------------------------------------------------------------------------------

 Различие операторов сравнения


---------------------------------------------------------------------------------------------

 Какие есть falsy значения?


---------------------------------------------------------------------------------------------

 Какие ты знаешь типы функций?


---------------------------------------------------------------------------------------------

 Зачем нам нужны стрелочные функции?


---------------------------------------------------------------------------------------------

 Как появляется контекст у функции?


---------------------------------------------------------------------------------------------

 Чем отличается синхронный код от асинхронного?


---------------------------------------------------------------------------------------------

 Мутабельные и имутабельные типы данных


---------------------------------------------------------------------------------------------

 Операторы сравнения



---------------------------------------------------------------------------------------------

 Что такое контекст в функции?



---------------------------------------------------------------------------------------------

 Отличие синхронного от асинхронного кода



---------------------------------------------------------------------------------------------

 Изучал ли браузерный js



---------------------------------------------------------------------------------------------

 Опыт работы с анимациями


---------------------------------------------------------------------------------------------

 Что такое тернарный оператор



---------------------------------------------------------------------------------------------
 Про псевдомассив arguments



---------------------------------------------------------------------------------------------

 Про typeof function


---------------------------------------------------------------------------------------------

 Как проверить что в переменной массив


---------------------------------------------------------------------------------------------

 Про parseFloat


---------------------------------------------------------------------------------------------

 Про Array.indexOf


---------------------------------------------------------------------------------------------

 Про Array.includes


---------------------------------------------------------------------------------------------

 Про onClick


---------------------------------------------------------------------------------------------

 Как удалить eventListener


---------------------------------------------------------------------------------------------

 Как передвигаться впередназад по истории


---------------------------------------------------------------------------------------------

 Как получить текущий URL страницы


---------------------------------------------------------------------------------------------

 Как средиректить пользователя на URL


---------------------------------------------------------------------------------------------

 В чем разница между spread и rest операторами


---------------------------------------------------------------------------------------------

 Про rest оператор


---------------------------------------------------------------------------------------------

 Что такое деструктуризация


---------------------------------------------------------------------------------------------

 Для чего нужен Promose.all


---------------------------------------------------------------------------------------------

 Задача про счастливые числа


---------------------------------------------------------------------------------------------

 Задача про url параметры


---------------------------------------------------------------------------------------------

 Как поставить cookie в браузере


---------------------------------------------------------------------------------------------

 Как проверить, что переменная NaN


---------------------------------------------------------------------------------------------

 Как проверить, что число целое



---------------------------------------------------------------------------------------------

 Разница между function declaration и function expression



---------------------------------------------------------------------------------------------

 Как поменять значения двух переменных местами



---------------------------------------------------------------------------------------------


 Разница между == и ===

 «==» используется для сравнения двух значений независимо от типа данных переменной. т.е. производится неявное приведение типов.
 «===» используется для сравнения двух значений, но это будет строгая проверка, поэтому будет проверяться соответствие значения и типа данных. Производится сравнение без приведения типов.

---------------------------------------------------------------------------------------------


 Как проверить, является ли значение числом?
     isNaN()Функция определяет, является ли значение не числом.
     Если вы используете isNaN(), вам придется выполнить дополнительные проверки , как вы можете видеть из приведенных ниже примеров.


---------------------------------------------------------------------------------------------


 Как преобразовать строку в int?

     parseInt()преобразует строку в целое число
 parseInt("30", 10)  30
 parseInt("55px", 10)  50
 parseInt(2.55, 10)  2
 parseFloat()преобразует строку в число точек (с десятичным числом)
 Пример:
     parseFloat("30")  30
 parseFloat("55px")  50
 parseFloat(2.55)  2.55
 Вы также можете принять
 Number()преобразует строку в число. Это может быть целое число или число точек. Они часто могут быть менее безопасными, чем использование parseIntилиparseFloat

---------------------------------------------------------------------------------------------


 Назовите различные циклы в JavaScript

 for- перебирает блок кода несколько раз
 forin- перебирает свойства объекта
 forof- перебирает значения итерируемого объекта
 while- перебирает блок кода, пока заданное условие истинно
 dowhile- также перебирает блок кода, пока заданное условие выполняется


---------------------------------------------------------------------------------------------

 Разница между slice и splice



---------------------------------------------------------------------------------------------

 Как отсортировать массив чисел по возрастанию



---------------------------------------------------------------------------------------------

 Переписать конструктор на ES6 синтаксис



---------------------------------------------------------------------------------------------

 Как узнать, что объект пустой



---------------------------------------------------------------------------------------------

 Сделать первую букву строки заглавной



---------------------------------------------------------------------------------------------

 Что делает метов freeze



---------------------------------------------------------------------------------------------

 Как инвертировать порядок элементов массива



---------------------------------------------------------------------------------------------

 Найти max и min значения в массиве



---------------------------------------------------------------------------------------------

 Spread оператор со строкой



---------------------------------------------------------------------------------------------

 Получить символ из строки по index



---------------------------------------------------------------------------------------------

 Как получить массив уникальных элементов



---------------------------------------------------------------------------------------------

 Как очистить массив от всех элементов



---------------------------------------------------------------------------------------------

 Как отсортировать в массиве только нечетные числа



---------------------------------------------------------------------------------------------

 Как удалить обработчик события


---------------------------------------------------------------------------------------------

 Про return из функции



---------------------------------------------------------------------------------------------

 Про изменение ссылки на объект



---------------------------------------------------------------------------------------------

 Пересечение массивов (простой вариант задачи)



---------------------------------------------------------------------------------------------

 Какие бывают  состояния у Promise



---------------------------------------------------------------------------------------------
Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?



---------------------------------------------------------------------------------------------

 Задача про var и setTimeout



---------------------------------------------------------------------------------------------

 Разница между Object.getOwnPropertyNames и Object.keys



---------------------------------------------------------------------------------------------

 При клике на кнопку нужно удалить кнопку и отрисовать 2 новых



---------------------------------------------------------------------------------------------

 Про arrow function и обработчик события



---------------------------------------------------------------------------------------------

 Чем отличаются PUT и POST запросы



---------------------------------------------------------------------------------------------

 Для чего нужен package-lock.json



---------------------------------------------------------------------------------------------

 Что такое staging area в git



---------------------------------------------------------------------------------------------

 В чем разница между merge и rebase



---------------------------------------------------------------------------------------------

 Какие pet project’ы делала



---------------------------------------------------------------------------------------------

 Подключении скриптов через script



---------------------------------------------------------------------------------------------

 Что такое всплытие событий(event bubbling)



---------------------------------------------------------------------------------------------

 stopPropagationpreventDefault



---------------------------------------------------------------------------------------------

 Какие типы данных есть в JS



---------------------------------------------------------------------------------------------

 Способы итерации по массивам



---------------------------------------------------------------------------------------------

 Разница между for и froEach



---------------------------------------------------------------------------------------------

 Чем forEach отличается от map

Чтобы понять разницу между ними, давайте посмотрим, что делает каждая функция.

forEach
Перебирает элементы в массиве.
Вызывает callback-функцию для каждого элемента.
Не возвращает значение.
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  // Делаем что-либо с num и/или index.
});
// doubled = undefined

map
Перебирает элементы в массиве.
“Сопоставляет” каждый элемент с новым элементом, вызывая функцию для каждого элемента, создавая в результате новый массив.
const a = [1, 2, 3];
const doubled = a.map(num => {
  return num * 2;
});
// doubled = [2, 4, 6]

Основное различие между .forEach и .map() состоит в том, что .map() возвращает новый массив. Если вам нужен результат, но вы не хотите изменять исходный массив, .map() — очевидный выбор. Если вам просто нужно перебрать массив, то стоит воспользоваться forEach.

---------------------------------------------------------------------------------------------

 Метод reduce



---------------------------------------------------------------------------------------------

 delete элемента массива



---------------------------------------------------------------------------------------------

 Разница между Func() и new Func()



---------------------------------------------------------------------------------------------

 Как скопировать простой объект



---------------------------------------------------------------------------------------------

 Изоморфная функция добавления



---------------------------------------------------------------------------------------------

 Функция возвращающая расширение файла



---------------------------------------------------------------------------------------------

 Способы уменьшения времени загрузки страницы




---------------------------------------------------------------------------------------------

 В чем плюсы SSR



---------------------------------------------------------------------------------------------

 Способы уменьшения времени загрузки страницы



---------------------------------------------------------------------------------------------

 HTTP заголовки кеширования



---------------------------------------------------------------------------------------------

 Cookies



---------------------------------------------------------------------------------------------

 Security поля в cookie



---------------------------------------------------------------------------------------------

 Про схлопывание отступов



---------------------------------------------------------------------------------------------

 Про inline-block и проблему с пробелами



---------------------------------------------------------------------------------------------

 Что такое this в JS

Нельзя в двух словах объяснить работу ключевого слова this; это одно из самых запутанных понятий в JavaScript. Говоря максимально простым языком, значение this зависит от того, как вызывается функция.
Применяются следующие правила:
1. Если ключевое слово new используется при вызове функции, this внутри функции является совершенно новым объектом.
2. Если для вызова/создания функции используются apply, call или bind, то this внутри функции — это объект, который передается в качестве аргумента.
3. Если функция вызывается как метод, например, obj.method(), то this — это объект, к которому принадлежит функция.
4. Если функция вызывается без контекста, то есть она вызывается без условий, описанных в пунктах выше, то this является глобальным объектом. В браузере это объект window. В строгом режиме (’use strict’), this будет undefined вместо глобального объекта.
5. Если применяются несколько из вышеперечисленных правил, то правило, которое выше выигрывает и устанавливает значение this.
6. Если функция является стрелочной функцией, то она игнорирует все вышеописанные правила и получает значение this из лексического окружения во время ее создания.

---------------------------------------------------------------------------------------------

 use strict и this



---------------------------------------------------------------------------------------------
 Как проверить что объект это массив



---------------------------------------------------------------------------------------------

 Про логические операторы && и ||



---------------------------------------------------------------------------------------------

 Разница меджу function expression и function declaration



---------------------------------------------------------------------------------------------

 IIFE

IIFE расшифровывается как Immediately Invoked Function Expression — немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает function foo(){ } (); как function foo(){ } и ();, где первое выражение — это объявление функции, а второе (пара скобок) — попытка вызова функции, но так как имя не указано, он выдает ошибку Uncaught SyntaxError: Unexpected token.
Вот два способа исправить это, которые заключаются добавление дополнительных скобок: (function foo(){ })() и (function foo(){ }()).
Выражения, начинающиеся с function, считаются объявлениями функций. Оборачивая эту функцию внутри (), она становится функциональным выражением, которое затем может быть выполнено с последующим (). Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.
Вы также можете использовать оператор void — void function foo(){ }().
К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает undefined, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать.
Пример:
const foo = void function bar() { return ‘foo’; }();
console.log(foo); // undefined

---------------------------------------------------------------------------------------------

Объясните делегирование событий

Делегирование событий — это приём, заключающийся в добавлении обработчиков событий к родительскому элементу, а не к дочерним элементам. Обработчик будет срабатывать всякий раз, когда событие будет запущено на дочерних элементах благодаря всплытию событий в DOM.
Преимущества этого приёма:
Экономит объем используемой памяти, т.к. для родительского элемента требуется только один обработчик.
Не нужно привязывать или убирать обработчики при добавлении и удалении элементов.

---------------------------------------------------------------------------------------------

 Передача значений по ссылке



---------------------------------------------------------------------------------------------

 Метод filter и остаток от деления



---------------------------------------------------------------------------------------------

 Унарный оператор инкремента



---------------------------------------------------------------------------------------------

 Числа с плавающей точкой



---------------------------------------------------------------------------------------------

 Сравнение объектов



---------------------------------------------------------------------------------------------

    В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и .call, и .apply используются для вызова функций, а также первый параметр будет использоваться как значение this внутри функции. А разница в том, что .call в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как .apply в качестве следующих аргументов принимает массив аргументов.
function add(a, b) {
  return a + b;
}
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3

---------------------------------------------------------------------------------------------
    bind

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

---------------------------------------------------------------------------------------------
    В каких случаях используется `document.write()`?

document.write() записывает строку текста в поток документа, открытого при помощи document.open(). Когда document.write() выполняется после загрузки страницы, он вызывает document.open, который очищает весь документ (<head>и<body> будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

---------------------------------------------------------------------------------------------
 Скоуп переменных



---------------------------------------------------------------------------------------------

 Какие у нас существуют функции в JS?



---------------------------------------------------------------------------------------------

 В чем разница между function expression и function declaration?



---------------------------------------------------------------------------------------------

 Откуда берется контекст у функции?



---------------------------------------------------------------------------------------------

 Что такое чистая функция?



---------------------------------------------------------------------------------------------

 Как мы можем изменить контекст у функции?



---------------------------------------------------------------------------------------------

 Что такое eval и почему его следует избегать?



---------------------------------------------------------------------------------------------

 Чем область видимости отличается от контекста?



---------------------------------------------------------------------------------------------

 Что такое замыкание?

Замыкание — это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово “лексический” относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания — это функции, которые имеют доступ к переменным внешней (замыкающей) функции — цепочке областей видимости даже после того, как внешняя функция вернулась.

---------------------------------------------------------------------------------------------

 Как работают модули в ES modules?



---------------------------------------------------------------------------------------------

 Можем ли мы поменять переменную в модуле извне?



---------------------------------------------------------------------------------------------

 Как мы можем эмулировать модули не используя ES modulesrequire?



---------------------------------------------------------------------------------------------

 Откуда берется свойство length у массива?



---------------------------------------------------------------------------------------------


 Чем отличаются PUT- и POST-запросы?

     PUT-запросы приводят к замене целевого ресурса на данные, передаваемые в запросе. Его можно использовать для обновления содержимого существующего ресурса или для создания нового ресурса.

     POST-запросы приводят к специфической для ресурса обработке данных, передаваемых в запросе. Их можно использовать для выполнения различных действий. В том числе — для создания новых ресурсов, для выгрузки файлов на сервер, для отправки форм.

     Ещё одно отличие между PUT- и POST-запросами заключается в том, что PUT-запросы являются идемпотентными, а POST-запросы — нет. То есть — если запрос, в котором передаются одни и те же данные, и который выполняется по одному и тому же URL, будет выполнен несколько раз, это равносильно однократному выполнению этого запроса. Многократное выполнение POST-запроса не эквивалентно его однократному выполнению. То есть — несколько таких запросов, например, могут привести к созданию нескольких объектов на сервере.

---------------------------------------------------------------------------------------------


 Объясните, что такое файлы cookie в JavaScript
 С помощью этого вопроса интервьюер оценивает ваши базовые знания в веб-разработке.

     Ответ: Cookies – это небольшие текстовые файлы, которые хранятся на компьютере и создаются, когда пользователь заходит на веб-сайты. Например, это могут быть сведения о пользователе или информация о содержимом корзины покупок из прошлых посещений.


---------------------------------------------------------------------------------------------


 Чем отличаются cookie, sessionStorage и localStorage?

localStorage, как можно понять из его названия, это место, которое браузеры могут использовать для локального хранения данных. В нём может храниться до 10 Мб данных.

sessionStorage — это разновидность локального хранилища, которое привязано к сессии и удаляется после её завершения. В сессионном хранилище может храниться до 5 Мб данных.

Куки-файлы используются для хранения небольших объёмов данных, не превышающих 4 Кб. Ими может пользоваться браузер, их может запрашивать у браузера сервер.

Инициатор

cookie - Клиент или сервер. Сервер может использовать заголовок Set-Cookie
localStorage - Клиент
sessionStorage - Клиент

Срок хранения

cookie -Устанавливается вручную
localStorage - Всегда
sessionStorage - До закрытия вкладки

Хранение между сессиями

cookie - Зависит от установки срока хранения
localStorage - Да
sessionStorage - Нет

Отправка на сервер с каждым HTTP-запросом

cookie - автоматически, с помощью заголовка Cookie
localStorage - Нет
sessionStorage - Нет

Емкость (на один домен)

cookie - 4 КБ
localStorage - 	5 МБ
sessionStorage - 	5 МБ

Доступность

cookie - В любом окне
localStorage - 	В любом окне
sessionStorage - 	В той же вкладке

---------------------------------------------------------------------------------------------


 Что такое CORS?

     CORS (Cross-Origin Resource Sharing, совместное использование ресурсов между разными источниками) — это браузерный механизм, который позволяет предоставлять страницам доступ к ресурсам, расположенным за пределами некоего домена. Это расширяет возможности страниц и добавляет гибкости политике одинакового источника (same-origin policy).

---------------------------------------------------------------------------------------------


 Что такое промис?

     Промисы — это объекты, которые используются в JavaScript при выполнении асинхронных операций. Они упрощают работу с асинхронными операциями и дают более удобные механизмы обработки ошибок, чем коллбэки и события.

---------------------------------------------------------------------------------------------


 В каких состояниях может пребывать промис?

     Промис может пребывать в одном из трёх состояний:

     Исполнено (fulfilled) — операция, связанная с промисом, завершена успешно.
 Отклонено (rejected) — операция, связанная с промисом, завершена с ошибкой.
 Ожидание (pending) — промис находится в состоянии ожидания, то есть, о нём нельзя сказать, что он завершён успешно или с ошибкой.


---------------------------------------------------------------------------------------------
    Что такое поднятие переменных и функций в JavaScript (hoisting)?

 Поднятие переменных и функций (hoisting) — это перемещение их объявлений в верхнюю часть их области видимости (глобальной области видимости или области видимости функции).


---------------------------------------------------------------------------------------------


 Какие значения в JavaScript являются ложными?

     В JavaScript ложными являются значения, которые, при преобразовании их к логическому типу, становятся значениями false. Это — следующие значения:

     ''
 0
 null
 undefined
 NaN
 false
 -0
 0n  значения типа BigInt, при преобразовании их к логическому типу, ведут себя так же, как значения типа Number


---------------------------------------------------------------------------------------------


 Объясните стрелочные функции
 Ответ: Стрелочная функция – это краткий способ записи функциональных выражений.

     Стрелочные функции не являются конструкторами, не поддерживают ключевые слова this, arguments, super и new.target


---------------------------------------------------------------------------------------------


 Объясните NaN и его роль
 Когда интервьюер просит дать определение термину, этот термин, как правило, является широко используемым. В этом случае, термин NaN, который означает «не число» – важная концепция, понимание которой, потребуется разработчикам на JavaScript при работе с числовыми значениями.

     Ответ: Когда значение в операции не число, оно возвращает NaN. Это может произойти в нескольких случаях. Например, если операция возвращает неподходящий результат, потому что часть функции была нечисловой или результат имеет значение, не являющееся числовым.


---------------------------------------------------------------------------------------------


 Что такое примитивные типы данных в JavaScript?
     Такой вопрос обычно оценивает ваши теоретические знания JavaScript. При ответе на этот вопрос рассмотрите возможность краткого перечисления всех примитивных типов данных, доступных в JavaScript.

     Ответ: Фундаментальный тип данных, который не может быть создан от других типов данных. Он ограничен представлением одного значения. Все примитивы неизменяемы (immutable), не являются объектом и не имеют методов. По определению, все примитивы – встроенные типы данных, и компилятор должен знать их. Но не все встроенные типы данных – примитивы. В JavaScript доступно семь примитивных типов данных: undefined, null, boolean, string, number, bigint, symbol. Все остальное в JavaScript является объектом.


---------------------------------------------------------------------------------------------


 Как рассчитать числа Фибоначчи в JavaScript?
     Создать последовательность чисел Фибоначчи – очень популярная задача для программистов. Попробуйте правильно ответить на него с помощью кода.

     Ответ: Последовательность чисел Фибоначчи – это последовательность чисел, где каждое значение – это сумма двух предыдущих, начинается с 0 и 1. Первые пять значений это 0, 1, 1, 2, 3, 5, 8.


---------------------------------------------------------------------------------------------


 Как динамически добавлять и удалять свойства в JavaScript?
     Ответ: Вы можете добавить свойство к объекту используя, object.property_name = value, и удалить свойство, используя delete.

---------------------------------------------------------------------------------------------


 Объясните различие между Object.freeze() и const
     Ответ: const и Object.freeze – две разные фичи JavaScript. const применяется только для неизменяемой ссылки на ячейку памяти со значением, что означает невозможность задать новое значение для переменной.
     Object.freeze работает со значениями объектов. Делает объект неизменяемым, то есть изменить его свойства невозможно.

---------------------------------------------------------------------------------------------


 Для чего используются операторы break и continue в JavaScript?
     Эти два термина относятся к циклам. Попробуйте объяснить, как операторы break и continue влияют на цикл.

     Ответ: Оператор break выходит из запущенного цикла в то время как, оператор continue продолжает работу после прерывания всего одной итерации. Оба оператора позволяют написать сложную циклическую функцию с различными результатами и требуемыми действиями на основе заданного результата функции.

---------------------------------------------------------------------------------------------


 Зачем оборачивать содержимое исходного JS-файла в блок функции?
     Ответ на этот вопрос может показать ваши знания вспомогательных процессов, которые, скорее всего, специфичны для библиотеки.

     Ответ: Этот метод заключает в себя содержимое файла, создавая приватное пространство имен. Такая реализация позволяет избежать конфликта между объектами JavaScript и библиотеками, в которых они размещены.

---------------------------------------------------------------------------------------------


 Каковы преимущества и недостатки монолитной и микросервисной архитектуры?
     Интервьюер, вероятно, хочет увидеть, понимаете ли вы различия между ними и достаточно ли осведомлены о них, чтобы определить наиболее практичный подход в любой конкретной ситуации.

     Ответ: Монолитные архитектуры обычно реализуются как приложение в виде единого компонента, что упрощает добавление задач, связанных со сквозной функциональностью (англ. сross-cutting concern), таких как: ограничение запросов, ведение журнала и различные функции безопасности. То есть к сквозной относится «вспомогательная» функциональность модуля, не относящаяся напрямую к выполняемой задаче, но необходимая. Поначалу такая архитектура может показаться более практичной, но по мере развития приложения становится все труднее поддерживать код или масштабировать его.

     Стоит принимать во внимание, что микросервисы будут иметь широкий круг задач, связанных со сквозной функциональностью, которые не предполагались на этапе проектирования. В долгосрочной перспективе они, как правило, предпочтительнее из-за их автономной организации, что позволяет легко реструктурировать их по мере расширения или изменения их назначения.

---------------------------------------------------------------------------------------------
Расскажите, как работает прототипное наследование.

Все объекты в JavaScript имеют свойство prototype, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование.

---------------------------------------------------------------------------------------------
Что вы думаете о AMD против CommonJS?

Оба являются способами реализации системы модулей, которая изначально не присутствовала в JavaScript до появления ES2015. CommonJS является синхронным, в то время как AMD (Asynchronous Module Definition, асинхронное определение модуля) — соответственно, асинхронным. CommonJS разработан с учетом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначена для браузеров.
Синтаксис AMD довольно многословный, а CommonJS ближе к стилю, который используется в выражениях импорта в других языках. В большинстве случаев я считаю AMD ненужным, потому что если вы разместите весь свой код в одном объединенном файле, то вы не сможете воспользоваться свойствами асинхронной загрузки. Кроме того, синтаксис CommonJS ближе к стилю написания модулей Node, и поэтому происходит меньше путаницы при переключении между клиентской и серверной разработкой на JavaScript.

---------------------------------------------------------------------------------------------
В каких случаях обычно используются анонимные функции?

Они могут использоваться в IIFE для инкапсуляции кода в локальную область видимости, чтобы объявленные в ней переменные не попадали в глобальную область видимости.
(function() {
  // Здесь код функции.
})();

Как callback-функция, которая используется один раз и не должна использоваться где-либо еще. Код будет казаться более автономным и читаемым, когда обработчики будут определены прямо внутри вызывающего их кода, а не искать в другом месте, чтобы найти тело функции.
setTimeout(function() {
  console.log('Hello world!');
}, 1000);

Аргументы в конструкциях функционального программирования или Lodash (аналогично callback-функциям).
const arr = [1, 2, 3];
const double = arr.map(function(el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]

---------------------------------------------------------------------------------------------
    Как вы организуете свой код? (module pattern, classical inheritance)

Будет ли такой подход и ответ верным? (еще нужно все это осознать в применении...)

Модульный паттерн до сих пор хорош, но в настоящее время я использую React, который использует однонаправленный поток данных. Я создаю модели своего приложения при помощи простых объектов и пишу чистые функции для управления этими объектами.

---------------------------------------------------------------------------------------------
    В чем разница между host-объектами и нативными объектами?

Нативные объекты — это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript, такие как String, Math, RegExp, Object, Function и т.д.
Хост-объекты предоставляются средой выполнения (браузером или Node), такие как `window`, `XMLHTTPRequest` и т.д.

---------------------------------------------------------------------------------------------
    В чем разница между feature detection (определение возможностей браузера), feature inference (предположение возможностей) и анализом строки user-agent?

Feature detection (определение возможностей браузера)
Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода - и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:
if ('geolocation' in navigator) {
  // Можно использовать navigator.geolocation
} else {
  // Обработка отсутствия возможности
}
Modernizr - отличная библиотека для обработки таких функций.

Feature inference (предположение возможностей)
Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует, например:
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
Этот подход не рекомендуется. Первый подход более надежен.

Строка User Agent
Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя от которого исходит запрос. Доступ к ней можно получить через navigator.userAgent. Тем не менее, строка User Agent сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome, так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте этого метода.

---------------------------------------------------------------------------------------------
    Расскажите об Ajax как можно более подробно.

Ajax (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью Ajax веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, Ajax позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных JSON вместо XML из-за того, что JSON основан на JavaScript.

---------------------------------------------------------------------------------------------
    Какие преимущества и недостатки в использовании Ajax?

Преимущества

Повышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.
Сокращение количества подключений к серверу, поскольку скрипты и таблицы стилей нужно запрашивать только один раз.
Состояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.
Большая часть преимуществ SPA.

Недостатки

Сложнее реализовать добавление динамической веб-страницы в закладки.
Не работает, если в браузере отключен JavaScript.
Некоторые поисковые роботы не выполняют JavaScript и не видят данные, загружаемые при помощи JavaScript.
Большая часть недостатков SPA.

---------------------------------------------------------------------------------------------
    Объясните, как работает JSONP (и почему это не совсем AJAX).

JSONP (JSON с набивкой) - это способ, часто используемый для обхода политики ограничения домена в браузерах, потому что Ajax-запросы с текущей страницы к серверу, находящемуся в другом домене, запрещены.
JSONP работает, отправляя запрос к серверу в другом домене через тег <script> и обычно с параметром запроса callback, например:https://example.com?callback=printData. Затем сервер обернет данные внутри функции с именем printData и вернет их клиенту.

HTML:
<!-- https://mydomain.com -->
<script>
function printData(data) {
  console.log(`My name is ${data.name}!`);
}
</script>
<script src="https://example.com?callback=printData"></script>

JS:
// Файл загружен с https://example.com?callback=printData
printData({ name: 'Yang Shun' });

У клиента должна быть функция printData в своей глобальной области видимости, и эта функция будет выполнена клиентом, когда будет получен ответ с сервера из другого домена.
JSONP может быть небезопасным и иметь повышенный риск. Поскольку JSONP - это действительно JavaScript, и он может делать все остальное, что может делать JavaScript, то вы должны быть уверены в надежности поставщика данных JSONP.

---------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------
В чём разница между «атрибутом» (attribute) и «свойством« (property)?




---------------------------------------------------------------------------------------------
Почему не следует расширять нативные JavaScript-объекты?



---------------------------------------------------------------------------------------------
В чём разница между событием document load и событием document DOMContentLoaded?



---------------------------------------------------------------------------------------------
Объясните same-origin policy в контексте JavaScript.



---------------------------------------------------------------------------------------------
Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?


---------------------------------------------------------------------------------------------
Для чего используют событие load? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?


---------------------------------------------------------------------------------------------
Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.



---------------------------------------------------------------------------------------------
Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?



---------------------------------------------------------------------------------------------
Какие инструменты и методы вы используете при отладке кода?



---------------------------------------------------------------------------------------------
Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?



---------------------------------------------------------------------------------------------
Объясните разницу между изменяемыми (mutable) и неизменяемыми (immutable) объектами.
Приведите пример неизменяемого объекта в JavaScript.
Какие преимущества и недостатки у неизменяемости?
Как вы можете достигнуть неизменяемости в вашем коде?



---------------------------------------------------------------------------------------------
Что такое цикл событий (event loop)?
В чём разница между стеком вызовов (call stack) и очередью событий (task queue)?




---------------------------------------------------------------------------------------------
В чём разница между классом в ES6 и функцией-конструктором в ES5?



---------------------------------------------------------------------------------------------
Дайте определение функции высшего порядка.



---------------------------------------------------------------------------------------------
Каким образом можно обмениваться кодом между файлами?




---------------------------------------------------------------------------------------------
Для чего используются статические члены класса?



---------------------------------------------------------------------------------------------
Как работает «сборщик мусора» в JS?


---------------------------------------------------------------------------------------------
Что такое полифил?



---------------------------------------------------------------------------------------------
Что такое webpack?



---------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------

*/